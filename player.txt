# working movement without tiles
using Godot;
public partial class Player : CharacterBody2D

{
    [Export] public float SlideSpeed = 300f;

    private Vector2 _velocity = Vector2.Zero;
    private bool _isSliding = false;

    public override void _PhysicsProcess(double delta)
    {
        if (_isSliding)
        {
            // Set the velocity and move the character
            Velocity = _velocity;

            // Use MoveAndCollide for collision handling
            var collision = MoveAndCollide(_velocity * (float)delta);

            if (collision != null)
            {
                // Check if collision happens in the direction of movement
                Vector2 collisionNormal = collision.GetNormal();
                if (collisionNormal.Dot(_velocity.Normalized()) < 0) // Opposing direction
                {
                    // Stop sliding on valid collision
                    _isSliding = false;
                    _velocity = Vector2.Zero;
                }
                else
                {
                    // Ignore the collision since it's not in the direction of movement
                }
            }
        }
        else
        {
            // Input handling to start sliding
            if (Input.IsActionJustPressed("ui_up"))
                StartSliding(Vector2.Up);
            else if (Input.IsActionJustPressed("ui_down"))
                StartSliding(Vector2.Down);
            else if (Input.IsActionJustPressed("ui_left"))
                StartSliding(Vector2.Left);
            else if (Input.IsActionJustPressed("ui_right"))
                StartSliding(Vector2.Right);
        }
    }

    public void StartSliding(Vector2 direction)
    {
        _isSliding = true;
        _velocity = direction.Normalized() * SlideSpeed;
    }
}

///////////////////

// working tile movement but just one by one
using Godot;

public class SlidingCharacter : CharacterBody2D
{
    [Export] public float SlideSpeed = 300f;  // Speed of movement
    private const int GridSize = 10;  // Size of each grid cell

    private Vector2 _velocity = Vector2.Zero;
    private bool _isSliding = false;
    private Vector2 _direction = Vector2.Zero;

    public override void _PhysicsProcess(double delta)
    {
        if (_isSliding)
        {
            // Start sliding towards the target grid cell
            SlideUntilCollision();

            // Update position based on velocity
            Position += _velocity * (float)delta;

            // Check if the character has reached the target grid position
            if (Position == _direction)
            {
                _isSliding = false;
                SnapToGrid();
            }
        }
        else
        {
            // Input handling to start sliding
            if (Input.IsActionJustPressed("ui_up"))
                StartSliding(Vector2.Up);
            else if (Input.IsActionJustPressed("ui_down"))
                StartSliding(Vector2.Down);
            else if (Input.IsActionJustPressed("ui_left"))
                StartSliding(Vector2.Left);
            else if (Input.IsActionJustPressed("ui_right"))
                StartSliding(Vector2.Right);
        }
    }

    private void StartSliding(Vector2 direction)
    {
        // Set the initial sliding direction
        _direction = Position + direction * GridSize;

        // Check if the target position is valid (no collisions)
        if (IsPositionValid(_direction))
        {
            _isSliding = true;
            _velocity = direction.Normalized() * SlideSpeed;
        }
    }

    private void SlideUntilCollision()
    {
        // Move in the current direction until we hit a wall
        Vector2 nextPosition = Position + _velocity.Normalized() * GridSize;

        // Check if the next position is valid
        if (!IsPositionValid(nextPosition))
        {
            // Stop the movement if we hit a wall
            _velocity = Vector2.Zero;
        }
        else
        {
            // Continue moving towards the target
            _velocity = _velocity.Normalized() * SlideSpeed;
        }
    }

    private void SnapToGrid()
    {
        // Snap to the closest grid cell
        Position = new Vector2(
            Mathf.Round(Position.x / GridSize) * GridSize,
            Mathf.Round(Position.y / GridSize) * GridSize
        );
    }

    private bool IsPositionValid(Vector2 targetPosition)
    {
        var spaceState = GetWorld2D().DirectSpaceState;

        // Create a point query parameter (without exclusion for simplicity)
        var query = new PhysicsPointQueryParameters2D
        {
            Position = targetPosition,
            CollideWithAreas = true,  // Whether to check for area colliders
            CollideWithBodies = true  // Whether to check for body colliders (walls)
        };

        // Perform the point query and get the results
        var result = spaceState.IntersectPoint(query);

        // If no results, the position is valid (no collision)
        return result.Count == 0;
    }
}

